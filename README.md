# Алгоритмы и структуры данных

# Модуль 1

## Задача про сумму (A)

#### Ограничение времени:	3 с
#### Ограничение реального времени:	5 с
#### Ограничение памяти:	64M

На стандартном потоке ввода задаётся последовательность целых чисел.

Каждое число последовательности не меньше -200 000 000 и не больше 200 000 000.

На стандартный поток вывода напечатайте сумму этих чисел.

## Примеры

### Входные данные
#### 1 2 3 4

### Результат работы
#### 10

## Задача про стек (B)

#### Ограничение времени:	3 с
#### Ограничение реального времени:	5 с
#### Ограничение памяти:	64M

Реализуйте стек, используя только массив.

### Формат входных данных
На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Первая строка всегда содержит "set_size N", где N - максимальный размер стека, целое число.

Каждая последующая строка содержит ровно одну команду: push X, pop или print, где X - произвольная строка без пробелов.

### Формат результата
Команда print выводит содержимое стека (снизу вверх) одной строкой, значения разделяются пробелами. Если стек пуст, то выводится "empty".

В случае переполнения стека выводится "overflow".

Команда pop выводит элемент или "underflow", если стек пуст.

Память под стек должна быть выделена не более одного раза, при вызове команды "set_size".

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Примеры

### Входные данные
#### set_size 5
#### pop
#### push 1
#### push 2
#### push 3
#### push 4
#### push 5
#### print
#### push 6
#### pop
#### push 6
#### print

### Результат работы
#### underflow
#### 1 2 3 4 5
#### overflow
#### 5
#### 1 2 3 4 6

## Задача про очередь (C)

#### Имя входного файла:	input
#### Имя выходного файла:	output
#### Ограничение времени:	3 с
#### Ограничение реального времени:	5 с
#### Ограничение памяти:	64M

Это как задача про стек, только про очередь.

Реализуйте очередь, используя только массив.

Ввод и вывод данных осуществляется через файлы. Имена входного и выходного файлов задаются через аргументы командной строки (первый и второй соответственно).

### Формат входных данных
Во входном файле задаётся последовательность команд. Пустые строки игнорируются.

Первая строка всегда содержит "set_size N", где N - максимальный размер очереди, целое число.

Каждая последующая строка содержит ровно одну команду: push X, pop или print, где X - произвольная строка без пробелов.

### Формат результата
Команда print выводит содержимое очередь (от головы к хвосту) одной строкой, значения разделяются пробелами. Если очередь пуста, то выводится "empty".

В случае переполнения очереди выводится "overflow".

Команда pop выводит элемент или "underflow", если очередь пуста.

Память под очередь должна быть выделена не более одного раза, при вызове команды "set_size".

В любой непонятной ситуации результатом работы любой команды будет "error".

## Примеры

### Входные данные в файле input
#### set_size 5
#### pop
#### push 1
#### push 2
#### push 3
#### push 4
#### push 5
#### print
#### push 6
#### pop
#### push 6
#### print

### Результат работы в файле output
#### underflow
#### 1 2 3 4 5
#### overflow
#### 1
#### 2 3 4 5 6

## Задача про обход графа (D)

#### Ограничение времени:	10 с
#### Ограничение реального времени:	40 с
#### Ограничение памяти:	4294967295

Реализуйте обход графа в ширину и глубину.

Вершины упорядочены в лексикографическом порядке.

### Формат входных данных
Первая строка стандартного потока ввода данных имеет формат "[graph_type] [start_vertex] [search_type]",

где "[graph_type]" - тип графа, ориентированный ('d') или неориентированный ('u');

"[start_vertex]" - идентификатор вершины, с которой начинать обход графа;

"[search_type]" - тип обхода, в ширину ('b') или в глубину ('d').

Каждая последующая строка содержит ребро, которая представляет собой идентификаторы начальной и конечной вершины, разделенные пробелом.

### Формат результата
Результат работы программы выводится в стандартный поток вывода.

Идентификаторы посещенных вершин выводятся по одному в строке в порядке обхода.

## Примеры

### Входные данные	
#### u 1 d
#### 1 3
#### 1 2
#### 1 5
#### 2 3
#### 2 4
#### 5 4

### Результат работы
#### 1
#### 2
#### 3
#### 4
#### 5

# Модуль 2

## Задача про косое дерево (B)

#### Ограничение времени:	15 с
#### Ограничение реального времени:	20 с
#### Ограничение памяти:	4294967295

Реализуйте косое дерево (splay tree).

Реализация самой структуры данных должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и непосредственно ввода/вывода.

Тесты предполагают "левостороннюю" реализацию, т.е. если действие можно реализовать двумя симметричными способами, надо делать тот, который больше использует левую сторону.

### Формат входных данных
На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Каждая строка содержит ровно одну команду: add K V, set K V, delete K, search K, min, max или print, где K - целое число (64 бита вам хватит), ключ, V - произвольная строка без пробелов (значение).

### Формат результата
Команда add добавляет значение V в дерево по ключу K, set - изменяет данные по ключу, команда delete удаляет данные.

Команда search выводит либо "1 V", либо "0", где V - значение для найденного ключа.

Команды min и max выводят "K V", где K - минимальный или максимальный ключ дерева соответственно, V - значение по этому ключу.

Команда print выводит все дерево целиком. Она не изменяет дерево.

Дерево выводится строго по уровням, слева направо, 1 строка - 1 уровень. Первая строка содержит только корень дерева в формате "[K V]" или "_", если дерево пустое.

Каждая последующая строка содержит один уровень дерева. Вершины выводятся в формате "[K V P]", где P - ключ родительской вершины. Если вершина отсутствует, ставится "_". Вершины разделены пробелом.

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Примеры

### Входные данные
#### add 8 10
#### add 4 14
#### add 7 15
#### set 8 11
#### add 3 13
#### add 5 16
#### search 88
#### search 7
#### delete 5
#### print

### Результат работы
#### 0
#### 1 15
#### [4 14]
#### [3 13 4] [7 15 4]
#### _ _ _ [8 11 7]

## Непростая куча (C)

#### Ограничение времени:	3 с
#### Ограничение реального времени:	4 с
#### Ограничение памяти:	4294967295

Реализуйте двоичную min-кучу. Модифицируйте ее таким образом, чтобы внутреннее ее строение было таким же, но при этом доступ по ключу к любому элементу осуществлялся в среднем за константное время.

Реализация самой структуры данных должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и непосредственно ввода/вывода.

### Формат входных данных
На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Каждая строка содержит ровно одну команду: add K V, set K V, delete K, search K, min, max, extract или print, где K - целое число (64 бита вам хватит), ключ, V - произвольная строка без пробелов (значение).

### Формат результата
Команда add добавляет значение V в кучу по ключу K, set - изменяет данные по ключу, команда delete удаляет данные.

Команда search выводит либо "1 I V", либо "0", где I - индекс, V - значение для найденного ключа

Команды min и max выводят "K I V", где K - минимальный или максимальный ключ кучи соответственно, I - индекс, V - значение по этому ключу.

Команда extract извлекает корень кучи и выводит "K V", где K, V - ключ и значение извлеченного элемента.

Команда print выводит всю кучу целиком.

Куча выводится строго по уровням, слева направо, 1 строка - 1 уровень. Первая строка содержит только корень кучи в формате "[K V]" или "_", если куча пустая.

Каждая последующая строка содержит один уровень кучи. Вершины выводятся в формате "[K V P]", где P - ключ родительской вершины. Если вершина отсутствует, ставится "_". Вершины разделены пробелом.

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Примеры

### Входные данные
#### add 8 10
#### add 4 14
#### add 7 15
#### set 8 11
#### add 3 13
#### add 5 16
#### add 10 10
#### search 88
#### search 7
#### delete 4
#### extract
#### print

### Результат работы
#### 0
#### 1 2 15
#### 3 13
#### [5 16]
#### [8 11 5] [7 15 5]
#### [10 10 8] _ _ _

## Автокоррекция (D)

#### Ограничение времени:	2 с
#### Ограничение реального времени:	3 с
#### Ограничение памяти:	64M

Реализуйте программу, которая предлагает варианты замены слова, в котором допущена одна ошибка.

Для решения этой задачи реализуйте префиксное дерево (возможно сжатое)

Регистр букв для программы коррекции не имеет значения (слова в словаре хранятся в нижнем регистре).

Варианты ошибок - как в алгоритме Дамерау-Левенштейна: вставка лишнего символа, удаление символа, замена символа или транспозиция соседних символов.

Реализация алгоритма должна быть инкапсулирована. В комментариях напишите сложность ключевых алгоритмов с пояснением.

### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.

Первая строка содержит число N - количество слов в словаре.

Последующие N строк содержат слова из словаря, по одному в строке.

Остальные строки - слова, которые надо проверять.

### Формат результата
Каждая строка выхода содержит предложение для исправления слов, в порядке их появления.

Если слово не содержит ошибок, то выводится "%слово% - ok".

Если слово содержит одну ошибку, то выводится "%слово% -> %слово_в_словаре%". Если вариантов несколько, то они разделяются запятой с пробелом.

Если слово содержит более одной ошибки, то выводится "%слово% -?"

Результат работы программы выводится в стандартный поток вывода.

## Примеры

### Входные данные
#### 8
#### some
#### random
#### words
#### for
#### testing
#### your
#### solutions
#### far

#### some
#### randoms
#### wards
#### seeking
#### fro
#### solution
#### fur

### Результат работы
#### some - ok
#### randoms -> random
#### wards -> words
#### seeking -?
#### fro -> for
#### solution -> solutions
#### fur -> far, for

# Модуль 3

## Рюкзак (A)

#### Ограничение времени:	2 с
#### Ограничение реального времени:	3 с
#### Ограничение памяти:	64M

Решите задачу о рюкзаке методом динамического программирования. Алгоритм должен быть инкапсулирован.

### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.

Первая строка содержит целое неотрицательное число — максимальную массу предметов, которую выдержит рюкзак.

Каждая последующая содержит два целых неотрицательных числа: массу предмета и его стоимость.

### Формат результата
Первая строка содержит два числа: суммарную массу предметов и их суммарную стоимость.

В последующих строках записаны номера предметов, которые были помещены в рюкзак, в порядке возрастания номера.

Результат работы программы выводится в стандартный поток вывода.

В любой непонятной ситуации результатом работы любой команды будет "error".

## Примеры

### Входные данные
#### 165
#### 23 92
#### 31 57
#### 29 49
#### 44 68
#### 53 60
#### 38 43
#### 63 67
#### 85 84
#### 89 87
#### 82 72

### Результат работы
#### 165 309
#### 1
#### 2
#### 3
#### 4
#### 6

## Сумасшедший богач (B)

#### Ограничение времени:	2 с
#### Ограничение реального времени:	3 с
#### Ограничение памяти:	64M

Один сумасшедший богач на старости лет впал в маразм и стал еще более сумасшедшим. Он решил отдать половину своих богатств тому, кто выиграет в математической игре.

Правила игры: изначально каждый игрок начинает с нулевой суммой. Он может либо получить у богача 1 миллион сантиков, либо отдать ему 1 миллион сантиков, либо получить от богача ту же сумму, которая есть у него сейчас.

Выигрывает тот, кто за минимальное количество действий наберет сумму, равную половине состояния богача.

На беду других игроков, нашелся человек, который что-то слышал про жадные алгоритмы и двоичную систему счисления (возможно это вы).

### Формат входных данных
В стандартном потоке записано единственное натуральное число - размер половины состояния богача (в миллионах).

### Формат результата
Каждая строка выхода содержит ровно одну операцию (inc, dec или dbl) из кратчайшей последовательности действий для победы.

Результат работы программы выводится в стандартный поток вывода.

Внимание: в этом задании в ответах выводится только количество действий. Сами действия показаны не будут.

## Примеры

### Входные данные
#### 23

### Результат работы
#### inc
#### dbl
#### inc
#### dbl
#### dbl
#### dbl
#### dec

## Фильтр Блума (D)

#### Ограничение времени:	2 с
#### Ограничение реального времени:	3 с
#### Ограничение памяти:	64M

Реализуйте фильтр Блума, позволяющий дать быстрый, но вероятностный ответ, присутствует ли объект в коллекции.

Реализация самой структуры данных должна быть инкапуслирована, т.е. не зависеть от форматов входных/выходных данных и непосредственно ввода/вывода.

Реализация битового массива также должна быть инкапсулирована. Массив битов должен быть эффективно расположен в памяти.

Параметрами структуры данных являются n - приблизительное количество элементов (целое), P - вероятность ложноположительного ответа.

Размер структуры, m, вычисляется как -n log2 P / ln 2, а количество хэш-функций - как -log2 P. Оба значения округляются до ближайшего целого.

В качестве семейства функций используйте семейство хэш-функций вида

hi(x) = (((i + 1)*x + pi+1) mod M) mod m,

где - x - ключ, i - номер хэш-функции, pi - i-тое по счету простое число, а M - 31ое число Мерсенна.

### Формат входных данных
На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Первая строка содержит команду вида set n P.

Каждая последующая строка содержит ровно одну команду: add K, search K или print, где K - неотрицательное число (64 бита вам хватит), ключ.

### Формат результата
Команда set инициализирует структуру и выводит вычисленные параметры в формате "m k".

Команда add добавляет в структуру ключ K.

Команда search выводит либо "1", если элемент возможно присутствует в структуре, либо "0", если он там отсутствует.

Команда print выводит внутреннее состояние струтуры - последовательность из 0 и 1, не разделенную пробелами.

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Примеры

### Входные данные
#### set 2 0.250
#### add 7
#### add 5
#### add 14
#### print
#### search 7
#### search 10
#### search 15
#### search 14
#### search 5
#### search 13

### Результат работы
#### 6 2
#### 010111
#### 1
#### 0
#### 1
#### 1
#### 1
#### 1

---

(:
